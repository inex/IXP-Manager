<?php

namespace Repositories;

use Doctrine\ORM\EntityRepository;

/**
 * BGPSessionData
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class BGPSessionData extends EntityRepository
{

    /**
     * Get all the BGP peers of all peers
     *
     * This function is for generating the peering matrix based on data contained in the
     * `bgpsessiondata` table which is updated based on detected BGP sessions between
     * routers on the peering LAN(s) from sflow data.
     *
     * It returns an array of all BGP peers show their peers, such as:
     *
     *     array(57) {
     *         [42] => array(3) {
     *             ["shortname"] => string(10) "pchanycast"
     *             ["name"] => string(25) "Packet Clearing House DNS"
     *             ["peers"] => array(17) {
     *                   [2110] => string(4) "2110"
     *                   [2128] => string(4) "2128"
     *                   ...
     *             }
     *         }
     *         [112] => array(3) {
     *             ["shortname"] => string(5) "as112"
     *             ["name"] => string(17) "AS112 Reverse DNS"
     *             ["peers"] => array(20) {
     *                   [1213] => string(4) "1213"
     *                   [2110] => string(4) "2110"
     *                   ...
     *             }
     *         }
     *         ...
     *     }
     *
     * It also caches the results on a per VLAN, per protocol basis.
     *
     * @param int $vlan The VLAN ID of the peering LAN to query
     * @param int $protocol The IP protocol to query (4 or 6)
     * @param int|null $asn Optional ASN to limit the query to
     * @param bool $forceDb Set to true to ignore the cache and force the query to the database
     * @return array Array of peerings (as described above)
     * @throws \IXP_Exception Thrown if an invalid protocol or VLAN id is specified
     */
    public function getPeers( $vlan = null, $protocol = 6, $asn = null, $forceDb = false )
    {
        $key = "pm_sessions_{$vlan}_{$protocol}";

        if( !$forceDb && ( $apeers = \Zend_Registry::get( 'd2cache' )->fetch( $key ) ) )
            return $apeers;
        
        if( !in_array( $protocol, [ 4, 6 ] ) )
            throw new \IXP_Exception( 'Invalid protocol' );
        
        if( $vlan !== null && !( $evlan = $this->getEntityManager()->getRepository( '\Entities\Vlan' )->find( $vlan ) ) )
            throw new \IXP_Exception( 'Invalid VLAN' );
            
        $conn = $this->getEntityManager()->getConnection();
        $conn->setFetchMode( \PDO::FETCH_ASSOC );
        
        // need to construct a raw SQL here due to the schema design by NH
        $sql = "SELECT bs.*, srcip.*, dstip.*,
            vlis.virtualinterfaceid as visid, vlid.virtualinterfaceid as vidid,
            cs.shortname AS csshortname, cs.name AS csname, cs.autsys AS csautsys,
            cd.shortname AS cdshortname, cd.name AS cdname, cd.autsys AS cdautsys,
            vlan.id AS vlanid, vlan.name AS vlanname, vlan.number AS vlantag,
            COUNT( bs.packetcount ) AS packetcount
                
            FROM bgpsessiondata AS bs
                LEFT JOIN ipv{$protocol}address AS srcip ON bs.srcipaddressid = srcip.id
                LEFT JOIN ipv{$protocol}address AS dstip ON bs.dstipaddressid = dstip.id
                LEFT JOIN vlaninterface AS vlis ON srcip.id = vlis.ipv4addressid
                LEFT JOIN vlaninterface AS vlid ON dstip.id = vlid.ipv4addressid
                LEFT JOIN virtualinterface AS vis ON vlis.virtualinterfaceid = vis.id
                LEFT JOIN virtualinterface AS vid ON vlid.virtualinterfaceid = vid.id
                LEFT JOIN cust AS cs ON vis.custid = cs.id
                LEFT JOIN cust AS cd ON vid.custid = cd.id
                LEFT JOIN vlan AS vlan ON vlan.number = bs.vlan
         
        WHERE
            bs.protocol = {$protocol}
            AND packetcount >= 1";
        
        if( $vlan !== null && $evlan )
            $sql .= "\n            AND vlan.id = " . $evlan->getId();
        
        if( $asn !== null )
            $sql .= "\n            AND cs.autsys = " . intval( $asn );
            
        $sql .= "\n        GROUP BY bs.srcipaddressid, bs.dstipaddressid";
        
        $peers = $conn->fetchAll( $sql );
        
        $apeers = [];
    
        foreach( $peers as $p )
        {
            if( !isset( $apeers[ $p['csautsys'] ] ) )
            {
                $apeers[ $p['csautsys'] ] = [];
                $apeers[ $p['csautsys'] ]['shortname'] = $p['csshortname'];
                $apeers[ $p['csautsys'] ]['name']      = $p['csname'];
                $apeers[ $p['csautsys'] ]['peers']     = [];
            }
    
            $apeers[ $p['csautsys'] ]['peers'][ $p['cdautsys'] ] = $p['cdautsys'];
        }
    
        ksort( $apeers, SORT_NUMERIC );
    
        foreach( $apeers as $asn => $p )
            ksort( $apeers[ $asn ][ 'peers' ], SORT_NUMERIC );

        \Zend_Registry::get( 'd2cache' )->save( $key, $apeers, 3600 );
                
        return $apeers;
    }
    
}
