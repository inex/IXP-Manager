<?php

/*
 * Copyright (C) 2009 - 2019 Internet Neutral Exchange Association Company Limited By Guarantee.
 * All Rights Reserved.
 *
 * This file is part of IXP Manager.
 *
 * IXP Manager is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, version v2.0 of the License.
 *
 * IXP Manager is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GpNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License v2.0
 * along with IXP Manager.  If not, see:
 *
 * http://www.gnu.org/licenses/gpl-2.0.html
 */

namespace Repositories;

use Doctrine\ORM\EntityRepository;

use IPTools\Network as IPToolsNetwork;

use Repositories\Traits\IPAddress as IPAddressTrait;

/**
 * IPv6Address
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class IPv6Address extends EntityRepository
{
    use IPAddressTrait;

    /**
     * Returns IPv6 addresses array for given customer
     *
     * Return array contains only IPv6 addresses like:
     * ["x:x:x:x:x:x:x:x", "x:x:x:x:x:x:x:x", ..., "x:x:x:x:x:x:x:x"]
     *
     * @param \Entities\Customer
     * @return array
     */
    public function getArrayForCustomer( $customer )
    {
        $addresses = $this->getEntityManager()->createQuery(
            "SELECT ip6.address AS address
        
             FROM \\Entities\\IPv6Address ip6
                 LEFT JOIN ip6.VlanInterface vi
                 LEFT JOIN vi.VirtualInterface viri
        
             WHERE viri.Customer = ?1"
        )
            ->setParameter( 1, $customer )
            ->getArrayResult();

        if( !$addresses )
            return [];
        else
            return array_map( 'current', $addresses );
    }

    /**
     * Find VLAN interfaces by (partial) IP address
     *
     * @param  string $ip The IP address to search for
     * @return \Entities\VlanInterface[] Matching interfaces
     */
    public function findVlanInterfaces( $ip )
    {
        return $this->getEntityManager()->createQuery(
            "SELECT vli
        
                 FROM \\Entities\\VlanInterface vli
                 LEFT JOIN vli.IPv6Address ip

                 WHERE ip.address LIKE :ip"
        )
            ->setParameter( 'ip', strtolower( "%{$ip}" ) )
            ->getResult();
    }


    /**
     * Get all IPv6 address for listing on the frontend
     *
     * @param int $vlanid Get all IP for a vlan ?
     *
     * @return array All Ip address
     */
    public function getAllForList( int $vlanid = null )
    {

        $dql = "SELECT  ip.id AS id, 
                        ip.address AS address,
                        hex( inet6_aton( ip.address ) ) as aton,
                        v.name AS vlan, 
                        v.id AS vlanid,
                        vli.id AS vliid,
                        vli.ipv6hostname AS hostname,
                        c.name AS customer, 
                        c.id AS customerid,
                        vi.id AS viid
                        
                FROM Entities\\IPv6Address ip
                LEFT JOIN ip.Vlan AS v
                LEFT JOIN ip.VlanInterface AS vli
                LEFT JOIN vli.VirtualInterface AS vi
                LEFT JOIN vi.Customer AS c ";


        if( $vlanid ) {
            $dql .= " WHERE v.id = " . (int)$vlanid;
        }

        $dql .= " ORDER BY address ASC";


        $query = $this->getEntityManager()->createQuery( $dql );

        return $query->getArrayResult();
    }


    /**
     * For a given IPTools library network object, generate sequential IPv6 addresses.
     *
     * There is also a `$decimal` option which only returns IPv6 addresses where the
     * last block uses only decimal numbering. This exists because typically IXs allocate
     * a customer an IPv6 address such that the last block matches the last block of the
     * IPv4 address. So, if set, the function will generate the number of addresses as
     * indicated by the CIDR block size but skip over any addresses containing
     * `a-f` characters. **NB:** the full number of addresses will be generated which means
     * this would typically overflow the subnet bound (unless $nooverflow is set).
     *
     * @param IPToolsNetwork $network
     * @param bool           $decimal
     * @param bool           $overflow
     *
     * @return array Generated addresses (string[])
     *
     * @throws
     */
    public static function generateSequentialAddresses( IPToolsNetwork $network, bool $decimal = false, bool $overflow = true ): array
    {
        assert( $network->getFirstIP()->getVersion() == 'IPv6' );
        $addresses = [];

        if( $decimal ) {

            $ip = $network->getFirstIP();
            $target = 2 ** ( 128 - $network->getPrefixLength() );
            $i      = 0;
            $loops  = 0;

            do {
                if( ++$loops == $target && !$overflow ) {
                    break;
                }

                if( !preg_match( '/^([0-9]+|)$/', substr( $ip, strrpos( $ip, ':' ) + 1 ) ) ) {
                    $ip = $ip->next();
                    continue;
                }

                $addresses[] = (string)$ip;
                $ip = $ip->next();
                $i++;

            } while( $i < $target );

        } else {

            foreach( $network as $ip ) {
                $addresses[] = (string)$ip;
            }

        }

        return $addresses;
    }

}