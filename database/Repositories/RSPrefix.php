<?php

namespace Repositories;

use Doctrine\ORM\EntityRepository;

/**
 * RSPrefix
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class RSPrefix extends EntityRepository
{
    /**
     * Return route acceptance counts for a specific customers as an aggregated array.
     *
     * A sample element of the array is (RS = Route Server):
     *
     *     [
     *         [total] => 10           // total routes of all types
     *         [adv_acc] => [          // routes advertised to the RS and accepted by the RS
     *             [4] => 6            // IPv4
     *             [6] => 2            // IPv6
     *             [total] => 8        // total
     *         ]
     *         [adv_nacc] => [         // routes advertised but not accepted (not in IRRDB)
     *             [4] => 0
     *             [6] => 1
     *             [total] => 1
     *         ]
     *         [nadv_acc] => [         // routes not advertised but that would be accepted
     *             [4] => 0
     *             [6] => 1
     *             [total] => 1
     *         ]
     *     ]
     *
     *
     * @return array Route acceptance counts for all customers as an aggregated array
     */
    public function aggregateRouteSummariesForCustomer( $custid )
    {
        $summary = $this->_initialiseAggregateRouteSummariesArray();
    
        foreach( \Entities\RSPrefix::$SUMMARY_TYPES_FNS as $type => $fn )
        {
            foreach( [ 4, 6 ] as $protocol )
            {
                if( $sum = $this->$fn( $protocol, $custid ) )
                {
                    $summary[ $type ][ $protocol ] = $sum['prefixes'];
                    $summary[ $type ]['total'] += $sum['prefixes'];
                    $summary[ 'total' ] += $sum['prefixes'];
                }
            }
        }
    
        return $summary;
    }
    
    /**
     * Return route acceptance counts for all customers as an aggregated array.
     *
     * A sample element of the array is (RS = Route Server):
     *
     *     [64] => [                   // customer ID
     *         [total] => 10           // total routes of all types
     *         [adv_acc] => [          // routes advertised to the RS and accepted by the RS
     *             [4] => 6            // IPv4
     *             [6] => 2            // IPv6
     *             [total] => 8        // total
     *         ]
     *         [adv_nacc] => [         // routes advertised but not accepted (not in IRRDB)
     *             [4] => 0
     *             [6] => 1
     *             [total] => 1
     *         ]
     *         [nadv_acc] => [         // routes not advertised but that would be accepted
     *             [4] => 0
     *             [6] => 1
     *             [total] => 1
     *         ]
     *         [name] => Customer Name
     *     ]
     *
     *
     * @return array Route acceptance counts for all customers as an aggregated array
     */
    public function aggregateRouteSummaries()
    {
        $summary = [];
        
        foreach( \Entities\RSPrefix::$SUMMARY_TYPES_FNS as $type => $fn )
        {
            foreach( [ 4, 6 ] as $protocol )
            {
                foreach( $this->$fn( $protocol ) as $routes )
                {
                    // initialise customer's summary array if necessary
                    if( !isset( $summary[ $routes['id'] ] ) )
                    {
                        $summary[ $routes['id'] ] = $this->_initialiseAggregateRouteSummariesArray();
                        $summary[ $routes['id'] ][ 'name' ] = $routes['name'];
                    }
                    
                    $summary[ $routes['id'] ][ $type ][ $protocol ] = $routes['prefixes'];
                    $summary[ $routes['id'] ][ $type ]['total'] += $routes['prefixes'];
                    $summary[ $routes['id'] ][ 'total' ] += $routes['prefixes'];
                }
            }
        }
        
        return $summary;
    }
    
    /**
     * Used to initialise customer array elements for @see getAggregateRouteSummaries()
     *
     * This isn't really necessary but it prevents a ton of isset() queries at the
     * presentation layer.
     *
     * @return array Initialised customer element array
     */
    private function _initialiseAggregateRouteSummariesArray()
    {
        $init = [
            'total' => 0
        ];
        
        foreach( \Entities\RSPrefix::$SUMMARY_TYPES_FNS as $type => $fn )
        {
            $init[ $type ] = [
                4       => 0,
                6       => 0,
                'total' => 0
            ];
        }
        
        return $init;
    }
    
    /**
     * Returns a count of all routes advertised to the route server and accepted by
     * it for all customers / a specific customer.
     *
     * @param int $protocol The protocol to count routes for (accepts ''4'' or ''6'')
     * @param int $cust The customer ID to limit the results for
     * @return array Count of all routes advertised to the route server and accepted by it
     */
    public function getSummaryRoutesAdvertisedAndAccepted( $protocol, $cust = null )
    {
        return $this->getSummaryRoutes( $protocol, 1, false, $cust );
    }
    
    /**
     * Returns a count of all routes not advertised to the route server but that would
     * be accepted by it for all customers / a specific customer.
     *
     * @param int $protocol The protocol to count routes for (accepts ''4'' or ''6'')
     * @param int $cust The customer ID to limit the results for
     * @return array Count of all routes not advertised to the route server but would be accepted by it
     */
    public function getSummaryRoutesAdvertisedAndNotAccepted( $protocol, $cust = null )
    {
        return $this->getSummaryRoutes( $protocol, 0, false, $cust );
    }
    
    /**
     * Returns a count of all routes advertised to the route server but not accepted by
     * it for all customers / a specific customer.
     *
     * @param int $protocol The protocol to count routes for (accepts ''4'' or ''6'')
     * @param int $cust The customer ID to limit the results for
     * @return array Count of all routes advertised to the route server but not accepted by it
     */
    public function getSummaryRoutesNotAdvertisedButAcceptable( $protocol, $cust = null )
    {
        return $this->getSummaryRoutes( $protocol, 1, true, $cust );
    }
    
    /**
     * Utility function used by the ''getSummaryRoutesXXX()'' function to query the database.
     *
     * The rules for routes are:
     *
     * * Advertised & Accepted: irrdb = 1 AND rs_origin IS NOT NULL
     * * Advertised & NOT Accepted: irrdb = 0 AND rs_origin IS NOT NULL
     * * Not Advertised & Acceptable: irrdb = 1 AND rs_origin IS NULL
     *
     * @param int $protocol The IP protocol to limit results to (accepts ''4'' or ''6'')
     * @param int $irrdb Limit results to ''irrdb = 1'' or ''irrdb = 0''
     * @param bool $rsOriginIsNull Limit results depending on whether the rs_origin is null or not
     * @param int $cust The customer ID to limit the results to
     * @return array The database query result (or false if none)
     */
    public function getSummaryRoutes( $protocol, $irrdb, $rsOriginIsNull, $cust = null )
    {
        $sql =
                'SELECT c.id AS id, c.name AS name, dp.protocol AS protocol,
                        dp.irrdb AS irrdb, count( dp.protocol ) AS prefixes
    
                FROM \\Entities\\RSPrefix dp
                    LEFT JOIN dp.Customer c
                WHERE
                    dp.rs_origin IS ' . ( $rsOriginIsNull ? '' : 'NOT' ) . ' NULL
                    AND dp.irrdb = ?2
                    AND dp.protocol = ?1 '
                    . ( $cust === null ? '' : ' AND c.id = ?3 ' ) . '
    
                GROUP BY c.id
                ORDER BY c.name ASC, dp.protocol ASC, dp.irrdb ASC';
        
        $query = $this->getEntityManager()->createQuery( $sql )
            ->setParameter( 1, $protocol )
            ->setParameter( 2, $irrdb );
        
        if( $cust !== null )
        {
            try
            {
                return $query->setParameter( 3, $cust )
                    ->getSingleResult();
            }
            catch( \Doctrine\ORM\NoResultException $e )
            {
                return false;
            }
        }
        
        return $query->getArrayResult();
    }


    
    /**
     * Return categorised routes for a given customer as an aggregated array.
     *
     * A sample element of the array is (RS = Route Server):
     *
     *     [
     *         [adv_acc] => [                             // Routes advertised and accepted
     *             [0] => [
     *                 [id] => 64                         // Customer ID
     *                 [name] => ABC Limited              // Customer Name
     *                 [protocol] => 4                    // protocol (4,6)
     *                 [irrdb] => 1                       // 1 if the route is in IRRDB
     *                 [prefix] => 192.0.2.0/24           // prefix
     *                 [timestamp] => DateTime Object
     *                 [rsorigin] => 65500                // origin AS
     *             ]
     *             ...
     *         ]
     *         [adv_nacc] => [                            // Routes advertised but not accepted
     *             ...
     *         ]
     *         [nadv_acc] => [                            // Routes not advertised but acceptable
     *             ...
     *         ]
     *     ]
     *
     * @param int $cust The customer ID to return routes for
     * @param int protocol The (optional) protocol to limit results to (''4'', ''6'', ''NULL'')
     * @return array Categorised routes for a given customer as an aggregated array.
     */
    public function aggregateRoutes( $cust, $protocol = null )
    {
        $aggRoutes = [];
    
        foreach( \Entities\RSPrefix::$ROUTES_TYPES_FNS as $type => $fn )
            $aggRoutes[ $type ] = $this->$fn( $protocol, $cust );
    
        return $aggRoutes;
    }
    
    /**
     * Returns all routes advertised to the route server and accepted by
     * it for all customers / a specific customer.
     *
     * @param int $protocol The protocol to count routes for (accepts ''null'', ''4'' or ''6'')
     * @param int $cust The customer ID to limit the results for
     * @return array All routes advertised to the route server and accepted by it
     */
    public function getRoutesAdvertisedAndAccepted( $protocol = null, $cust = null )
    {
        return $this->getRoutes( 1, false, $protocol, $cust );
    }
    
    /**
     * Returns all routes not advertised to the route server but that would
     * be accepted by it for all customers / a specific customer.
     *
     * @param int $protocol The protocol to count routes for (accepts ''null'', ''4'' or ''6'')
     * @param int $cust The customer ID to limit the results for
     * @return array All routes not advertised to the route server but would be accepted by it
     */
    public function getRoutesAdvertisedAndNotAccepted( $protocol = null, $cust = null )
    {
        return $this->getRoutes( 0, false, $protocol, $cust );
    }
    
    /**
     * Returns all routes not advertised to the route server but that would
     * be accepted by it for all customers / a specific customer.
     *
     * @param int $protocol The protocol to count routes for (accepts ''null'', ''4'' or ''6'')
     * @param int $cust The customer ID to limit the results for
     * @return array All routes not advertised to the route server but would be accepted by it
     */
    public function getRoutesNotAdvertisedButAcceptable( $protocol = null, $cust = null )
    {
        return $this->getRoutes( 1, true, $protocol, $cust );
    }
    
    /**
     * Utility function used by the ''getRoutesXXX()'' function to query the database.
     *
     * The rules for routes are:
     *
     * * Advertised & Accepted: irrdb = 1 AND rs_origin IS NOT NULL
     * * Advertised & NOT Accepted: irrdb = 0 AND rs_origin IS NOT NULL
     * * Not Advertised & Acceptable: irrdb = 1 AND rs_origin IS NULL
     *
     * @param int $irrdb Limit results to ''irrdb = 1'' or ''irrdb = 0''
     * @param bool $rsOriginIsNull Limit results depending on whether the rs_origin is null or not
     * @param int $protocol The IP protocol to limit results to (accepts ''null'', ''4'' or ''6'')
     * @param int $cust The customer ID to limit the results to
     * @return array The database query result
     */
    public function getRoutes( $irrdb, $rsOriginIsNull, $protocol = null, $cust = null )
    {
        $sql =
                'SELECT c.id AS id, c.name AS name, dp.protocol AS protocol,
                        dp.irrdb AS irrdb, dp.prefix AS prefix,
                        dp.timestamp AS timestamp, dp.rs_origin AS rsorigin
    
                FROM \\Entities\\RSPrefix dp
                    LEFT JOIN dp.Customer c
                        
                WHERE
                    dp.rs_origin IS ' . ( $rsOriginIsNull ? '' : 'NOT' ) . ' NULL
                    AND dp.irrdb = ?2 '
                    . ( $protocol === null ? '' : ' AND dp.protocol = ?1 ' )
                    . ( $cust === null ? '' : ' AND c.id = ?3 ' ) . '
    
                ORDER BY c.name ASC, dp.protocol ASC, dp.irrdb ASC';
    
        $query = $this->getEntityManager()->createQuery( $sql )
            ->setParameter( 2, $irrdb );
    
        if( $protocol !== null )
            $query->setParameter( 1, $protocol );
        
        if( $cust !== null )
            $query->setParameter( 3, $cust );
    
        return $query->getArrayResult();
    }
    
}
