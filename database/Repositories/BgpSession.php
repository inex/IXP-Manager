<?php

/*
 * Copyright (C) 2009 - 2019 Internet Neutral Exchange Association Company Limited By Guarantee.
 * All Rights Reserved.
 *
 * This file is part of IXP Manager.
 *
 * IXP Manager is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, version v2.0 of the License.
 *
 * IXP Manager is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GpNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License v2.0
 * along with IXP Manager.  If not, see:
 *
 * http://www.gnu.org/licenses/gpl-2.0.html
 */

namespace Repositories;

use Doctrine\ORM\EntityRepository;

use D2EM, Cache;

use Entities\{
    IPv4Address     as IPv4AddressEntity,
    IPv6Address     as IPv6AddressEntity,
    Vlan            as VlanEntity,
    VlanInterface   as VlanInterfaceEntity
};

/**
 * BgpSession
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class BgpSession extends EntityRepository
{

    /**
     * Get all the BGP peers of all peers
     *
     * This function is for generating the peering matrix based on data contained in the
     * `bgpsession` table which is updated based on detected BGP sessions between
     * routers on the peering LAN(s) from sflow data.
     *
     * It returns an array of all BGP peers show their peers, such as:
     *
     *     array(57) {
     *         [42] => array(3) {
     *             ["shortname"] => string(10) "pchanycast"
     *             ["name"] => string(25) "Packet Clearing House DNS"
     *             ["peers"] => array(17) {
     *                   [2110] => string(4) "2110"
     *                   [2128] => string(4) "2128"
     *                   ...
     *             }
     *         }
     *         [112] => array(3) {
     *             ["shortname"] => string(5) "as112"
     *             ["name"] => string(17) "AS112 Reverse DNS"
     *             ["peers"] => array(20) {
     *                   [1213] => string(4) "1213"
     *                   [2110] => string(4) "2110"
     *                   ...
     *             }
     *         }
     *         ...
     *     }
     *
     * It also caches the results on a per VLAN, per protocol basis.
     *
     * @param int $vlan The VLAN ID of the peering LAN to query
     * @param int $protocol The IP protocol to query (4 or 6)
     * @param int|null $asn Optional ASN to limit the query to
     * @param bool $forceDb Set to true to ignore the cache and force the query to the database
     *
     * @return array Array of peerings (as described above)
     *
     * @throws
     */
    public function getPeers( $vlan = null, $protocol = 6, $asn = null, $forceDb = false )
    {
        $key = "pm_sessions_{$vlan}_{$protocol}";

        if( !$forceDb && ( $apeers = Cache::get( $key ) ) ) {
            return $apeers;
        }

        if(  $vlan !== null && !( $evlan = D2EM::getRepository( VlanEntity::class )->find( $vlan ) ) ) {
            abort( 404 );
        }


        $conn = $this->getEntityManager()->getConnection();
        $conn->setFetchMode( \PDO::FETCH_ASSOC );

        // we've added "bs.timestamp >= NOW() - INTERVAL 7 DAY" below as we don't
        // dump old date (yet) and the time to run the query is O(n) on number
        // of rows...

        $sql = "SELECT  bs.*, 
                        srcip.*, 
                        dstip.*,
                        vlis.virtualinterfaceid as visid, 
                        vlid.virtualinterfaceid as vidid,
                        cs.shortname AS csshortname, 
                        cs.name AS csname, 
                        cs.autsys AS csautsys,
                        cs.activepeeringmatrix AS csactivepeeringmatrix,
                        cd.shortname AS cdshortname, 
                        cd.name AS cdname, 
                        cd.autsys AS cdautsys,
                        vlan.id AS vlanid,
                        vlan.name AS vlanname, 
                        vlan.number AS vlantag,
                        bs.packetcount AS packetcount

            FROM bgp_sessions AS bs
                LEFT JOIN ipv{$protocol}address AS srcip ON bs.srcipaddressid = srcip.id
                LEFT JOIN ipv{$protocol}address AS dstip ON bs.dstipaddressid = dstip.id
                LEFT JOIN vlaninterface AS vlis ON srcip.id = vlis.ipv{$protocol}addressid
                LEFT JOIN vlaninterface AS vlid ON dstip.id = vlid.ipv{$protocol}addressid
                LEFT JOIN virtualinterface AS vis ON vlis.virtualinterfaceid = vis.id
                LEFT JOIN virtualinterface AS vid ON vlid.virtualinterfaceid = vid.id
                LEFT JOIN cust AS cs ON vis.custid = cs.id
                LEFT JOIN cust AS cd ON vid.custid = cd.id
                LEFT JOIN vlan AS vlan ON vlan.id = srcip.vlanid

        WHERE
            bs.last_seen >= NOW() - INTERVAL 7 DAY
            AND bs.protocol = {$protocol}
            AND bs.packetcount >= 1";

        if( $evlan ){
            $sql .= " AND vlan.id = " . $evlan->getId();
        }


        if( $asn !== null ){
            $sql .= " AND cs.autsys = " . intval( $asn );
        }


        $sql .= " GROUP BY bs.srcipaddressid, bs.dstipaddressid, bs.id, vlis.virtualinterfaceid, vlid.virtualinterfaceid";
        $peers = $conn->fetchAll( $sql );
        $apeers = [];

        foreach( $peers as $p )
        {
            if( !isset( $apeers[ $p['csautsys'] ] ) )
            {
                $apeers[ $p['csautsys'] ] = [];
                $apeers[ $p['csautsys'] ]['shortname']           = $p['csshortname'];
                $apeers[ $p['csautsys'] ]['name']                = $p['csname'];
                $apeers[ $p['csautsys'] ]['activepeeringmatrix'] = $p['csactivepeeringmatrix'];
                $apeers[ $p['csautsys'] ]['peers']               = [];
            }

            $apeers[ $p['csautsys'] ]['peers'][ $p['cdautsys'] ] = $p['cdautsys'];
        }

        ksort( $apeers, SORT_NUMERIC );

        foreach( $apeers as $asn => $p ) {
            ksort( $apeers[ $asn ][ 'peers' ], SORT_NUMERIC );
        }

        Cache::put( $key, $apeers, 3600 );
        return $apeers;
    }


    /**
     * Get all the peers status
     *
     * @param VlanInterfaceEntity $vli VlanInterface
     *
     * @return array
     *
     * @throws
     */
    public function getPeersStatus( VlanInterfaceEntity $vli ){

        $IPAddresses = [];

        $request = [];

        foreach( [ 4,6 ] as $protocol ){
            $ipvFunction = "getIPv{$protocol}Address";

            //foreach( $vli->getVlan()->getVlanInterfaces() as $vlanInterface ){

                /** @var $vlanInterface VlanInterfaceEntity */
                if( $vli->$ipvFunction() ){
                    $IPAddresses[ $protocol ][] = $vli->$ipvFunction()->getId();


                    $request[ $protocol ] = $this->getEntityManager()->createQuery(
                        "SELECT bs
                    FROM \\Entities\\BgpSession as bs
                    WHERE bs.srcipaddressid IN (" . implode(",", $IPAddresses[ $protocol ] ) . ")  
                    AND bs.protocol = " . $protocol . "
                    AND bs.packetcount > 3
                    AND bs.last_seen > :date"

                    )->setParameter( 'date', new \DateTime('-3 years') )
                        ->getArrayResult();
                }


            //}




        }

        return $request;
    }


}