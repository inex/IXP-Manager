<?php

/*
 * Copyright (C) 2009 - 2019 Internet Neutral Exchange Association Company Limited By Guarantee.
 * All Rights Reserved.
 *
 * This file is part of IXP Manager.
 *
 * IXP Manager is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, version v2.0 of the License.
 *
 * IXP Manager is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GpNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License v2.0
 * along with IXP Manager.  If not, see:
 *
 * http://www.gnu.org/licenses/gpl-2.0.html
 */

namespace Repositories;

use Auth, D2EM;

use Doctrine\ORM\EntityRepository;

use Entities\{
    Customer     as CustomerEntity,
    CustomerNote as CustomerNoteEntity,
    User         as UserEntity
};

/**
 * CustomerNote
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class CustomerNote extends EntityRepository {

    /**
     * Return an array of ordered customer notes
     *
     * @param int  $custid      The customer ID to fetch notes for
     * @param bool $publicOnly
     * @return \Entities\CustomerNote[] An array of all customer notes objects
     */
    public function ordered( int $custid, bool $publicOnly = false ) {
        return $this->getEntityManager()->createQuery(
                "SELECT n FROM Entities\CustomerNote n WHERE n.Customer = ?1 "
                . ( $publicOnly ? "AND n.private = 0 " : "" )
                . "ORDER BY n.created_at DESC"
            )
            ->setParameter( 1, $custid )
            ->getResult();
    }
    

    /**
     * Return an array of the latest created / updated note for all customer's with notes.
     *
     * Array has the form:
     *
     *     [
     *         0 => [
     *             'cname' => 'ABC Networks Limited',
     *             'cid' => 9,
     *             'cshortname' => 'abcnetworks'
     *             'latest' => '2013-04-02 16:34:15'
     *         ]
     *         ...
     *     ]
     *
     */
    public function getLatestUpdate(){
        return $this->getEntityManager()->createQuery(
                "SELECT c.name AS cname, c.id AS cid, c.shortname AS cshortname, MAX( cn.updated ) AS latest
                
                FROM Entities\\Customer c
                    LEFT JOIN c.Notes AS cn

                GROUP BY cname, cid, cn.Customer HAVING COUNT( cn.Customer ) > 0
                
                ORDER BY latest DESC"
            )
            ->getArrayResult();
    }


    /**
     * Load a customer's notes and calculate the amount of unread / updated notes
     * for the logged in user and the given customer
     *
     * @deprecated Used by the old ZF dashboard only. Remove once ZF is gone.
     *
     * @param int        $custid      The customer ID
     * @param bool       $publicOnly
     * @param UserEntity $u
     *
     * @return array
     */
    public function fetchCustomerNotes( $custid, $publicOnly ) {
        $custNotes      = $this->ordered( $custid, $publicOnly );
        $unreadNotes    = 0;
        $rut            = Auth::getUser()->getPreference( "customer-notes.read_upto" );
        $lastRead       = Auth::getUser()->getPreference( "customer-notes.{$custid}.last_read" );

        if( $lastRead || $rut ) {
            foreach( $custNotes as $cn ) {
                /** @var CustomerNoteEntity $cn */
                $time = $cn->getUpdated()->format( "U" );
                if( ( !$rut || $rut < $time ) && ( !$lastRead || $lastRead < $time ) ){
                    $unreadNotes++;
                }
            }
        } else {
            $unreadNotes = count( $custNotes );
        }

        return [ "custNotes" => $custNotes, "notesReadUpto" => $rut , "notesLastRead" => $lastRead, "unreadNotes" => $unreadNotes];
    }

    /**
     * Fetch a customer's notes
     *
     * @param CustomerEntity $c          The customer
     * @param bool           $publicOnly
     * @return CustomerNoteEntity[]
     */
    public function fetchForCustomer( CustomerEntity $c, bool $publicOnly = false ) {
        return $this->ordered( $c->getId(), $publicOnly );
    }

    /**
     * Get note read statistics for a given set of notes and a user
     *
     * Returns an associate array with keys:
     *
     * * `notesReadUpto` - UNIX timestamp of when the user last read all notes / marked them as read
     * * `notesLastRead` - UNIX timestamp of when the user last read this customer's notes
     * * `unreadNotes`   - number of unread notes for this customer
     *
     * @param CustomerNoteEntity[] $cns
     * @param CustomerEntity       $c   The customer
     * @param UserEntity           $u   Optional user
     * @return array
     */
    public function analyseForUser( $cns, CustomerEntity $c, UserEntity $u ) {

        $unreadNotes    = 0;
        $rut            = $u->getPreference( "customer-notes.read_upto" );
        $lastRead       = $u->getPreference( "customer-notes.{$c->getId()}.last_read" );

        if( $lastRead || $rut ) {
            foreach( $cns as $cn ) {
                $time = $cn->getUpdated()->format( "U" );
                if( ( !$rut || $rut < $time ) && ( !$lastRead || $lastRead < $time ) ) {
                    $unreadNotes++;
                }
            }
        } else {
            $unreadNotes = count( $cns );
        }

        return [ "notesReadUpto" => $rut , "notesLastRead" => $lastRead, "unreadNotes" => $unreadNotes ];
    }
}
