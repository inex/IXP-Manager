<?php

namespace Repositories;

/*
 * Copyright (C) 2009 - 2019 Internet Neutral Exchange Association Company Limited By Guarantee.
 * All Rights Reserved.
 *
 * This file is part of IXP Manager.
 *
 * IXP Manager is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, version v2.0 of the License.
 *
 * IXP Manager is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License v2.0
 * along with IXP Manager.  If not, see:
 *
 * http://www.gnu.org/licenses/gpl-2.0.html
 */


use Auth, D2EM, Storage;

use Doctrine\ORM\EntityRepository;

use Entities\{
    PatchPanelPort              as PatchPanelPortEntity,
    PatchPanelPortHistory       as PatchPanelPortHistoryEntity,
    PatchPanelPortFile          as PatchPanelPortFileEntity,
    PatchPanelPortHistoryFile   as PatchPanelPortHistoryFileEntity
};

use IXP\Exceptions\GeneralException;

/**
 * Patch Panel Port Repository
 *
 * @author     Yann Robin <yann@islandbridgenetworks.ie>
 * @author     Barry O'Donovan <barry@islandbridgenetworks.ie>
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 *
 */
class PatchPanelPort extends EntityRepository
{



    /**
     * Get all the patch panel ports
     *
     * if $ppid is not null get all the patch panel port for the patch panel ID ( $ppid )
     *
     * @param   int     $ppid ID of the patch panel
     * @return  array
     */
    public function getAllPatchPanelPort(int $ppid = null):array {
        $dql = "SELECT ppp
                    FROM Entities\\PatchPanelPort ppp
                    JOIN ppp.patchPanel pp
                    WHERE ppp.duplexMasterPort IS NULL";

        if($ppid != null){
            $dql .= " AND pp.id = $ppid";
        }

        $dql .= " ORDER BY ppp.number ASC";

        $listPatchPanelPort = $this->getEntityManager()->createQuery( $dql )->getResult();

        return $listPatchPanelPort;
    }


    /**
     * Get all the patch panel ports available for a patch panel ID
     *
     * Possibility to exclude some ppp id from the list
     *
     * port available => PatchPanelPort::$AVAILABLE_FOR_ALLOCATION_STATES
     *
     * @param   int     $ppid ID of the patch panel
     * @param   array   $excludeIds Patch Panel Port ID that we want to exclude from the list
     * @return  array   list of patch panel form key => pppId , value => ppp name
     */
    public function getAvailablePorts( int $ppid, $excludeIds = [] ):array {
        $dql = "SELECT ppp
                    FROM Entities\\PatchPanelPort ppp
                    JOIN ppp.patchPanel pp
                    WHERE pp.id = $ppid
                    AND ppp.duplexMasterPort IS NULL
                    AND ppp.state IN (".implode(',', \Entities\PatchPanelPort::$AVAILABLE_FOR_ALLOCATION_STATES).") ";

        if( count( $excludeIds ) > 0) {
            $dql .= " AND ppp.id NOT IN (".implode(',', $excludeIds).") ";
        }

        $dql .= " ORDER BY ppp.number ASC";

        $availablePorts = $this->getEntityManager()->createQuery( $dql )->getResult();

        $listAvailablePort = array();

        /** @var PatchPanelPortEntity $port */
        foreach( $availablePorts as $port ){
            if( !$port->getDuplexSlavePort() ){
                $listAvailablePort[$port->getId()] = $port->getPatchPanel()->getPortPrefix().$port->getNumber();
            }
        }
        return $listAvailablePort;
    }

    /**
     * Check if the a switch port is available to be assign to a patch panel port
     *
     * @param   int $spid ID of the switch port
     * @return  boolean
     * @throws \Doctrine\ORM\NoResultException
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function isSwitchPortAvailable( $spid ){
        $dql = "SELECT count(ppp.id)
                    FROM Entities\\PatchPanelPort ppp
                    WHERE
                        ppp.switchPort = $spid";

        $query = $this->getEntityManager()->createQuery( $dql );
        $nb = $query->getSingleScalarResult();
        return ($nb > 0) ? false : true;
    }


    /**
     * Return the mailable class name for a given email type
     * @param int $type Email type
     * @return string Class name (or null)
     */
    public function resolveEmailClass( int $type ) {
        return isset( PatchPanelPortEntity::$EMAIL_CLASSES[ $type ] ) ? PatchPanelPortEntity::$EMAIL_CLASSES[ $type ] : null;
    }


    /**
     * Archive a patch panel port (and its slave ports)
     *
     * NB: does not reset the original port. This this, use:
     *
     *     $ppp->resetPatchPanelPort()
     *
     * @param PatchPanelPortEntity $ppp
     *
     * @return PatchPanelPortHistoryEntity
     *
     * @throws \LaravelDoctrine\ORM\Facades\ORMInvalidArgumentException
     */
    public function archive( PatchPanelPortEntity $ppp ): PatchPanelPortHistoryEntity {

        $ppph = new PatchPanelPortHistoryEntity();
        $ppph->setFromPatchPanelPort($ppp);
        $ppp->addPatchPanelPortHistory( $ppph );

        D2EM::persist($ppph);

        if( $ppp->hasSlavePort() ) {
            foreach( $ppp->getDuplexSlavePorts() as $pppsp ) {
                $sph = clone $ppph;
                $sph->setNumber( $pppsp->getNumber() );
                $sph->setDuplexMasterPort( $ppph );
                $sph->setPatchPanelPort( $pppsp );
                D2EM::persist( $sph );
            }
        }

        foreach( $ppp->getPatchPanelPortPublicFiles() as $pppf ) {
            $ppphf = new PatchPanelPortHistoryFileEntity;
            $ppphf->setFromPatchPanelPortFile( $pppf );
            $ppphf->addPatchPanelPortHistory( $ppph );
            $ppph->addPatchPanelPortHistoryFile( $ppphf );
            D2EM::persist( $ppphf );
            D2EM::remove( $pppf );
        }

        return $ppph;
    }

    /**
     * Remove the duplex link on a slave to a master port.
     *
     * In other words, set `duplex_master_id` to null (and add a private note
     * to reflect this).
     *
     * @param int $ppphid PatchPanelPortHistory ID
     */
    public function removeDuplexLinksTo( int $ppphid ) {
        $listDuplexPort = $this->getEntityManager()->createQuery(
            "SELECT ppph
                    FROM Entities\PatchPanelPortHistory ppph
                    WHERE ppph.duplexMasterPort = $ppphid"
            )->getResult();

        $un = Auth::check() ? Auth::user()->getUsername() : 'unkown/unauth';

        foreach( $listDuplexPort as $duplexPort ) {
            /** @var PatchPanelPortHistoryEntity $duplexPort */
            $duplexPort->setDuplexMasterPort( null );
            $duplexPort->setPrivateNotes(
                "### " . date('Y-m-d') . " - IXP Manager \n\nHad a master port that was deleted by {$un} on " . date('Y-m-d') . "\n\n"
                    . $duplexPort->getPrivateNotes()
            );
        }
    }

    /**
     * Remove a patch panel port and everything linked to it ( duplex port, files, histories, etc...)
     *
     * Also:
     *
     * * optionally deletes the linked slave port.
     * * deletes all the history.
     * * deletes in the database and on the disk all the files/filesHistory uploaded for this port.
     *
     * @param PatchPanelPortEntity $ppp the patch panel port that will be deleted
     * @param boolean $includeSlave if the patch panel port has a slave port, do we need to delete the slave port aswell ?
     *
     * @throws \Doctrine\ORM\OptimisticLockException
     */
    public function delete( PatchPanelPortEntity $ppp, bool $includeSlave = true ) {

        if( $ppp->hasSlavePort() ){
            if( $includeSlave ) {
                $this->delete( $ppp->getDuplexSlavePort() );
            } else {
                $ppp->getDuplexSlavePort()->resetPatchPanelPort();
            }
        }

        foreach( $ppp->getPatchPanelPortHistory() as $ppph ) {
            /** @var PatchPanelPortHistoryEntity $ppph */
            $this->removeDuplexLinksTo( $ppph->getId() );

            foreach( $ppph->getPatchPanelPortHistoryFile() as $ppphf ) {
                /** @var PatchPanelPortHistoryFileEntity $ppphf */
                $path = 'files/' . $ppphf->getPath();

                $ppph->removePatchPanelPortHistoryFile( $ppphf );
                $this->getEntityManager()->remove( $ppphf );
                if( Storage::exists( $path ) ){
                    Storage::delete( $path );
                }
            }

            $ppp->removePatchPanelPortHistory( $ppph );
            $this->getEntityManager()->remove( $ppph );
        }

        foreach( $ppp->getPatchPanelPortFiles() as $pppf ){
            /** @var PatchPanelPortFileEntity $pppf */
            $path = 'files/'.$pppf->getPath();

            $ppp->removePatchPanelPortFile( $pppf );
            $this->getEntityManager()->remove( $pppf );
            if( Storage::exists( $path ) ){
                Storage::delete( $path );
            }
        }

        $this->getEntityManager()->remove( $ppp );
        $this->getEntityManager()->flush();
    }

    /**
     * Load patch panel port objects allow them to be filtered by location, cabinet and/or cable type and/or available states.
     *
     * @param int  $location   Location ID (or zero for all)
     * @param int  $cabinet    Cabinet ID
     * @param int  $cabletype  Cable type (@see \Entities\PatchPanel::$CABLE_TYPES)
     * @param bool $availableForUse  available Port states (self::STATE_AVAILABLE, self::STATE_CEASED, self::STATE_AWAITING_CEASE, self::STATE_PREWIRED)
     *
     * @return array
     */
    public function advancedSearch( int $location, int $cabinet, int $cabletype, bool $availableForUse ) {
        $dql = "SELECT ppp
                  FROM Entities\PatchPanelPort ppp
                      LEFT JOIN ppp.patchPanel pp
                      LEFT JOIN pp.cabinet cab
                      LEFT JOIN cab.Location l ";

        $wheres = [];

        if( $location ) {
            $wheres[] = "l.id = " . $location;
        }

        if( $cabinet ) {
            $wheres[] = "cab.id = " . $cabinet;
        }

        if( $cabletype ) {
            $wheres[] = "pp.cable_type = " . $cabletype;
        }

        if( $availableForUse ) {
            $wheres[] = "ppp.state IN (" . implode( ',', PatchPanelPortEntity::$AVAILABLE_STATES ) .") ";
        }

        if( count( $wheres ) ) {
            $dql .= 'WHERE ' . implode(' AND ', $wheres);
        }

        $dql .= " ORDER BY pp.id ASC, ppp.number ASC";

        return $this->getEntityManager()->createQuery( $dql )->getResult();
    }


    /**
     * Wildcard search based on colo circuit ref or colo billing ref
     *
     * @param string  $ref   Colo ref or colo billing ref for %xxx% searcf
     *
     * @return PatchPanelPortEntity[]
     */
    public function findByColoRefs( string $ref )
    {
        $q = $this->getEntityManager()->createQuery(
            "SELECT ppp
                FROM Entities\PatchPanelPort ppp
                    LEFT JOIN ppp.patchPanel pp
                    LEFT JOIN pp.cabinet cab
                    LEFT JOIN cab.Location l 
                  WHERE ppp.colo_circuit_ref LIKE :ref
                  OR    ppp.colo_billing_ref LIKE :ref
                  ORDER BY pp.id ASC, ppp.id ASC"
            );

        $q->setParameter( 'ref', '%' . $ref . '%' );


        return $q->getResult();
    }


    /**
     * Move details / contents of a PPP to another PPP.
     *
     * Moves the information and files from a patch panel port to an other one
     * (and also move duplex slave if there is one). This function also:
     *
     * * Creates history of the old patch panel port
     * * Resets the old patch panel port (and duplex slave)
     *
     * @param PatchPanelPortEntity $source The old port
     * @param PatchPanelPortEntity $destination The target port
     * @param PatchPanelPortEntity $newSlavePort If `$source` is a duplex port, we need a new slave also.
     *
     * @return boolean
     *
     * @throws \Doctrine\ORM\OptimisticLockException|GeneralException
     * @throws \LaravelDoctrine\ORM\Facades\ORMInvalidArgumentException
     */
    public function move( PatchPanelPortEntity $source, PatchPanelPortEntity $destination, PatchPanelPortEntity $newSlavePort = null )
    {
        // preflight checks
        if( $source->hasSlavePort() && ( $newSlavePort === null || !$newSlavePort->isAvailableForUse() ) ) {
            throw new GeneralException( 'Source is duplex but no slave / free slave provided' );
        }

        if( !$destination->isAvailableForUse() ) {
            throw new GeneralException( 'Destination port is not available for use' );
        }

        if( !( $history = $this->archive( $source ) )  ) {
            return false;
        }
        
        // wipe source switch port as it is a unique constraint in the db
        $sp = $source->getSwitchPort();
        $source->setSwitchPort(null);

        // set all the data of the old port to the new master port
        $destination->setCustomer( $source->getCustomer() )
            ->setState(            $source->getState() )
            ->setColoCircuitRef(   $source->getColoCircuitRef() )
            ->setTicketRef(        $source->getTicketRef() )
            ->setNotes(            $source->getNotes() )
            ->setAssignedAt(       $source->getAssignedAt() )
            ->setConnectedAt(      $source->getConnectedAt() )
            ->setCeaseRequestedAt( $source->getCeaseRequestedAt() )
            ->setCeasedAt(         $source->getCeasedAt() )
            ->setLastStateChange(  $source->getLastStateChange() )
            ->setLoaCode(          $source->getLoaCode() )
            ->setInternalUse(      $source->getInternalUse() )
            ->setChargeable(       $source->getChargeable() )
            ->setOwnedBy(          $source->getOwnedBy() )
            ->setDescription(      $source->getDescription() )
            ->setSwitchPort(       $sp );

        $destination->setPrivateNotes(
            "### " . date('Y-m-d')." - IXP Manager\n\nMoved from "
            . $source->getPatchPanel()->getName() . "/" . $source->getName()
            . " by ". ( Auth::check() ? Auth::user()->getUsername() : "unknown/unauth" )
            . " on " . date('Y-m-d') . ".\n\n"
            . $source->getPrivateNotes()
        );

        if( $newSlavePort ){
            $destination->setDuplexPort( $newSlavePort );
        }


        foreach( $source->getPatchPanelPortFiles() as $pppf ){
            /** @var PatchPanelPortFileEntity $pppf */
            $pppf->setPatchPanelPort( $destination );
        }

        // Reset the old port
        $source->resetPatchPanelPort();

        $history->setPrivateNotes(
            "### " . date('Y-m-d')." - IXP Manager\n\nMoved to "
                . $destination->getPatchPanel()->getName() . "/" . $destination->getName()
                . " by ". ( Auth::check() ? Auth::user()->getUsername() : "unknown/unauth" )
                . " on " . date('Y-m-d') . ".\n\n"
                . ( $destination->hasFiles() ? "See new port for files.\n\n" : '' )
                . $history->getPrivateNotes()
        );

        D2EM::flush();

        return true;
    }


    /**
     * Return an array of the patch panel port cross connected
     *
     * @param $cid int The customer ID
     * @return array An array of all the  patch panel port entries
     */
    public function getForCustomer( $cid )
    {
        $crossConnected = $this->getEntityManager()->createQuery(
            "SELECT ppp
             FROM \\Entities\\PatchPanelPort ppp
             WHERE ppp.customer = ?1
             AND ppp.duplexMasterPort IS NULL"
        )
            ->setParameter( 1, $cid )
            ->getResult();

        return $crossConnected;
    }
}
