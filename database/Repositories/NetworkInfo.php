<?php

/*
 * Copyright (C) 2009 - 2019 Internet Neutral Exchange Association Company Limited By Guarantee.
 * All Rights Reserved.
 *
 * This file is part of IXP Manager.
 *
 * IXP Manager is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, version v2.0 of the License.
 *
 * IXP Manager is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GpNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License v2.0
 * along with IXP Manager.  If not, see:
 *
 * http://www.gnu.org/licenses/gpl-2.0.html
 */

namespace Repositories;

use Doctrine\ORM\EntityRepository;

use Entities\Infrastructure as InfrastructureEntity;

/**
 * NetworkInfo
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class NetworkInfo extends EntityRepository
{
    /**
     * Returns an array of the network information indexed by Vlan.id with
     * sub-arrays indexed by protocol.
     *
     * For example (where `x` is the vlan ID):
     *
     *     [x] => array(2) {
     *       [4] => array(9) {
     *         ["id"] => string(1) "1"
     *           ["protocol"] => string(1) "4"
     *           ["network"] => string(13) "193.242.111.0"
     *           ["masklen"] => string(2) "25"
     *           ["rs1address"] => string(13) "193.242.111.8"
     *           ["rs2address"] => string(13) "193.242.111.9"
     *           ["dnsfile"] => string(44) "/opt/bind/zones/reverse-vlan-10-ipv4.include"
     *           ["Vlan"] => array(5) {
     *             ["id"] => string(1) "2"
     *             ["name"] => string(15) "Peering VLAN #1"
     *             ["number"] => string(2) "10"
     *             ["rcvrfname"] => string(0) ""
     *             ["notes"] => string(0) ""
     *           }
     *       }
     *       [6] => array(9) {
     *         ["id"] => string(1) "2"
     *           ["vlanid"] => string(1) "2"
     *           ["protocol"] => string(1) "6"
     *           ["network"] => string(16) "2001:07F8:0018::"
     *           ["masklen"] => string(2) "64"
     *           ["rs1address"] => string(14) "2001:7f8:18::8"
     *           ["rs2address"] => string(14) "2001:7f8:18::9"
     *           ["dnsfile"] => string(44) "/opt/bind/zones/reverse-vlan-10-ipv6.include"
     *           ["Vlan"] => array(5) {
     *             ["id"] => string(1) "2"
     *             ["name"] => string(15) "Peering VLAN #1"
     *             ["number"] => string(2) "10"
     *             ["rcvrfname"] => string(0) ""
     *             ["notes"] => string(0) ""
     *           }
     *         }
     *     }
     *
     * @return array As described above
     */

    public function asVlanProtoArray()
    {
        $networkInfo = $this->getEntityManager()->createQuery(
                "SELECT n, v
                FROM \\Entities\\NetworkInfo n
                LEFT JOIN n.Vlan v"
            )->useResultCache( true, 3600 )
            ->getArrayResult();

        $data = array();
        foreach( $networkInfo as $ni )
        {
            $data[ $ni['Vlan']['id'] ][ $ni['protocol'] ] = $ni;
        }

        return $data;
    }

    public function asVlanEuroIXExportArray( InfrastructureEntity $infra )
    {
        $networkInfo = $this->getEntityManager()->createQuery(
                "SELECT n, v
                FROM \\Entities\\NetworkInfo n
                LEFT JOIN n.Vlan v
                LEFT JOIN v.Infrastructure i
                WHERE i.id = " . $infra->getId()
            )->useResultCache( true, 3600 )
            ->getArrayResult();

        $vlanentry = array();
        foreach( $networkInfo as $ni )
        {
            $id = $ni['Vlan']['id'];
            $vlanentry[$id]['id']                                   = $ni['Vlan']['id'];
            $vlanentry[$id]['name']                                 = $ni['Vlan']['name'];
            $vlanentry[$id][ 'ipv'.$ni['protocol'] ]['prefix']      = $ni[ 'network' ];
            $vlanentry[$id][ 'ipv'.$ni['protocol'] ]['mask_length'] = $ni[ 'masklen' ];
        }

        $data = array();
        foreach(array_keys($vlanentry) as $id){
            $data[] = $vlanentry[$id];
        }

        return $data;
    }


    /**
     * Get all networkinfo (or a particular one) for listing on the frontend CRUD
     *
     * @see \IXP\Http\Controllers\Doctrine2Frontend
     *
     *
     * @param \stdClass $feParams
     * @param int|null $id
     * @return array Array of networkinfo (as associated arrays) (or single element if `$id` passed)
     */
    public function getAllForFeList( \stdClass $feParams, int $id = null )
    {
        $dql = "SELECT  ni.id AS id, 
                        ni.protocol AS protocol, 
                        ni.network AS network, 
                        ni.masklen AS masklen, 
                        ni.rs1address AS rs1address, 
                        ni.rs2address AS rs2address, 
                        ni.dnsfile AS dnsfile,
                        vl.name AS vlanname,
                        vl.id AS vlanid
                FROM Entities\\NetworkInfo ni
                LEFT JOIN ni.Vlan vl     
                WHERE 1 = 1";

        if( $id ) {
            $dql .= " AND ni.id = " . (int)$id;
        }

        if( isset( $feParams->listOrderBy ) ) {
            $dql .= " ORDER BY " . $feParams->listOrderBy . ' ';
            $dql .= isset( $feParams->listOrderByDir ) ? $feParams->listOrderByDir : 'ASC';
        }

        $query = $this->getEntityManager()->createQuery( $dql );

        return $query->getArrayResult();
    }

}
