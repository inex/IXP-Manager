
#
# Bird v2 Route Server configuration generated by IXP Manager
#
# Do not edit this file, it will be overwritten. Please see:
#
# https://github.com/inex/IXP-Manager/wiki/Route-Server
#
# Generated: 2019-03-09 15:43:36
#

# For VLAN: Peering LAN 1 (Tag: 1, Database ID: 1)

# standardise time formats:
timeformat base         iso long;
timeformat log          iso long;
timeformat protocol     iso long;
timeformat route        iso long;


log "/var/log/bird/b2-rs1-lan1-ipv6.log" all;
log syslog all;

define routeserverasn     = 65501;
define routeserveraddress = 2001:db8::8;


router id 192.0.2.18;

# ignore interface up/down events
protocol device { }

# This function excludes weird networks
#  rfc1918, class D, class E, too long and too short prefixes
function avoid_martians()
prefix set martians;
{
    
        martians = [
                ::/0,                   # Default (can be advertised as a route in BGP to peers if desired)
                ::/96,                  # IPv4-compatible IPv6 address - deprecated by RFC4291
                ::/128,                 # Unspecified address
                ::1/128,                # Local host loopback address
                ::ffff:0.0.0.0/96+,     # IPv4-mapped addresses
                ::224.0.0.0/100+,       # Compatible address (IPv4 format)
                ::127.0.0.0/104+,       # Compatible address (IPv4 format)
                ::0.0.0.0/104+,         # Compatible address (IPv4 format)
                ::255.0.0.0/104+,       # Compatible address (IPv4 format)
                0000::/8+,              # Pool used for unspecified, loopback and embedded IPv4 addresses
                0200::/7+,              # OSI NSAP-mapped prefix set (RFC4548) - deprecated by RFC4048
                3ffe::/16+,             # Former 6bone, now decommissioned
                2001:db8::/32+,         # Reserved by IANA for special purposes and documentation
                2002:e000::/20+,        # Invalid 6to4 packets (IPv4 multicast)
                2002:7f00::/24+,        # Invalid 6to4 packets (IPv4 loopback)
                2002:0000::/24+,        # Invalid 6to4 packets (IPv4 default)
                2002:ff00::/24+,        # Invalid 6to4 packets
                2002:0a00::/24+,        # Invalid 6to4 packets (IPv4 private 10.0.0.0/8 network)
                2002:ac10::/28+,        # Invalid 6to4 packets (IPv4 private 172.16.0.0/12 network)
                2002:c0a8::/32+,        # Invalid 6to4 packets (IPv4 private 192.168.0.0/16 network)
                fc00::/7+,              # Unicast Unique Local Addresses (ULA) - RFC 4193
                fe80::/10+,             # Link-local Unicast
                fec0::/10+,             # Site-local Unicast - deprecated by RFC 3879 (replaced by ULA)
                ff00::/8+               # Multicast
        ];

    
        # Avoid RFC1918 and similar networks
        if net ~ martians then
                return false;

        return true;
}


########################################################################################
########################################################################################
#
# Community filtering definitions for use with looking glasses
#
# Current implementation based on:
#
# https://github.com/euro-ix/rs-workshop-july-2017/wiki/Route-Server-BGP-Community-usage
#
########################################################################################
########################################################################################



# These will all be filtered and not piped to the master table:

define IXP_LC_FILTERED_PREFIX_LEN_TOO_LONG      = ( routeserverasn, 1101, 1  );
define IXP_LC_FILTERED_PREFIX_LEN_TOO_SHORT     = ( routeserverasn, 1101, 2  );
define IXP_LC_FILTERED_BOGON                    = ( routeserverasn, 1101, 3  );
define IXP_LC_FILTERED_BOGON_ASN                = ( routeserverasn, 1101, 4  );
define IXP_LC_FILTERED_AS_PATH_TOO_LONG         = ( routeserverasn, 1101, 5  );
define IXP_LC_FILTERED_AS_PATH_TOO_SHORT        = ( routeserverasn, 1101, 6  );
define IXP_LC_FILTERED_FIRST_AS_NOT_PEER_AS     = ( routeserverasn, 1101, 7  );
define IXP_LC_FILTERED_NEXT_HOP_NOT_PEER_IP     = ( routeserverasn, 1101, 8  );
define IXP_LC_FILTERED_IRRDB_PREFIX_FILTERED    = ( routeserverasn, 1101, 9  );
define IXP_LC_FILTERED_IRRDB_ORIGIN_AS_FILTERED = ( routeserverasn, 1101, 10 );
define IXP_LC_FILTERED_PREFIX_NOT_IN_ORIGIN_AS  = ( routeserverasn, 1101, 11 );

define IXP_LC_FILTERED_RPKI_UNKNOWN             = ( routeserverasn, 1101, 12 );
define IXP_LC_FILTERED_RPKI_INVALID             = ( routeserverasn, 1101, 13 );
define IXP_LC_FILTERED_TRANSIT_FREE_ASN         = ( routeserverasn, 1101, 14 );
define IXP_LC_FILTERED_TOO_MANY_COMMUNITIES     = ( routeserverasn, 1101, 15 );




# Informational prefixes

define IXP_LC_INFO_RPKI_VALID       = ( routeserverasn, 1000, 1  );
define IXP_LC_INFO_RPKI_UNKNOWN     = ( routeserverasn, 1000, 2  );
define IXP_LC_INFO_RPKI_NOT_CHECKED = ( routeserverasn, 1000, 3  );

define IXP_LC_INFO_IRRDB_VALID         = ( routeserverasn, 1001, 1  );
define IXP_LC_INFO_IRRDB_NOT_CHECKED   = ( routeserverasn, 1001, 2  );
define IXP_LC_INFO_IRRDB_MORE_SPECIFIC = ( routeserverasn, 1001, 3  );

define IXP_LC_INFO_IRRDB_FILTERED_LOOSE  = ( routeserverasn, 1001, 1000 );
define IXP_LC_INFO_IRRDB_FILTERED_STRICT = ( routeserverasn, 1001, 1001 );
define IXP_LC_INFO_IRRDB_PREFIX_EMPTY    = ( routeserverasn, 1001, 1002 );

define IXP_LC_INFO_SAME_AS_NEXT_HOP = ( routeserverasn, 1001, 1200 );

# ( routeserverasn, 1010, peerasn ) -> route learnt from peerasn via routeserverasn
# ( routeserverasn, 1011, originasn ) -> route origin asn via routeserverasn


# And the filter for examining routes in the peers import table being exported
# to the master table

filter f_export_to_master
{

    if bgp_large_community ~ [( routeserverasn, 1101, * )] then reject;

    accept;
}






########################################################################################
########################################################################################
#
# Standard IXP community filter
#
########################################################################################
########################################################################################


function ixp_community_filter(int peerasn)
{
    if !(source = RTS_BGP) then
            return false;

    # AS path prepending
    if (routeserverasn, 103, peerasn) ~ bgp_large_community then {
        bgp_path.prepend( bgp_path.first );
        bgp_path.prepend( bgp_path.first );
        bgp_path.prepend( bgp_path.first );
    } else if (routeserverasn, 102, peerasn) ~ bgp_large_community then {
        bgp_path.prepend( bgp_path.first );
        bgp_path.prepend( bgp_path.first );
    } else if (routeserverasn, 101, peerasn) ~ bgp_large_community then {
        bgp_path.prepend( bgp_path.first );
    } else if (routeserverasn, 103, 0) ~ bgp_large_community then {
        bgp_path.prepend( bgp_path.first );
        bgp_path.prepend( bgp_path.first );
        bgp_path.prepend( bgp_path.first );
    } else if (routeserverasn, 102, 0) ~ bgp_large_community then {
        bgp_path.prepend( bgp_path.first );
        bgp_path.prepend( bgp_path.first );
    } else if (routeserverasn, 101, 0) ~ bgp_large_community then {
        bgp_path.prepend( bgp_path.first );
    }


    # support for BGP Large Communities
    if (routeserverasn, 0, peerasn) ~ bgp_large_community then
            return false;
    if (routeserverasn, 1, peerasn) ~ bgp_large_community then
            return true;
    if (routeserverasn, 0, 0) ~ bgp_large_community then
            return false;
    if (routeserverasn, 1, 0) ~ bgp_large_community then
            return true;

    # it's unwise to conduct a 32-bit check on a 16-bit value
    if routeserverasn > 65535 || peerasn > 65535 then
            return true;

    # Implement widely used community filtering schema.
    if (0, peerasn) ~ bgp_community then
            return false;
    if (routeserverasn, peerasn) ~ bgp_community then
            return true;
    if (0, routeserverasn) ~ bgp_community then
            return false;

    return true;
}




########################################################################################
########################################################################################
#
# RPKI protocol configuration
#
########################################################################################
########################################################################################


roa6 table t_roa;

protocol rpki rpki1 {

    roa6 { table t_roa; };

    remote "10.39.5.123" port 3323;

    retry keep 90;
    refresh keep 900;
    expire keep 172800;
}


protocol rpki rpki2 {

    roa6 { table t_roa; };

    remote "10.39.5.124" port 3323;

    retry keep 90;
    refresh keep 900;
    expire keep 172800;
}


/*
 * RPKI check for the path
 *
 * return: true means the filter should stop processing, false means keep processing
 */
function filter_rpki()
{
    # RPKI check
    if( roa_check( t_roa, net, bgp_path.last_nonaggregated ) = ROA_INVALID ) then {
        print "Tagging invalid ROA ", net, " for ASN ", bgp_path.last;
        bgp_large_community.add( IXP_LC_FILTERED_RPKI_INVALID );
        return true;
    }

    if( roa_check( t_roa, net, bgp_path.last_nonaggregated ) = ROA_VALID ) then {
        bgp_large_community.add( IXP_LC_INFO_RPKI_VALID );
        return true;
    }

    # RPKI unknown, keep checking and mark as unknown for info
    bgp_large_community.add( IXP_LC_INFO_RPKI_UNKNOWN );

    return false;
}





########################################################################################
########################################################################################
#
# Filter known transit networks
#
# Inspired by: http://bgpfilterguide.nlnog.net/guides/no_transit_leaks/
#
########################################################################################
########################################################################################


define TRANSIT_ASNS = [ 174, 701, 1299, 2914, 3257, 3320, 3356, 3491, 4134, 5511, 6453, 6461, 6762, 6830, 7018 ];

function filter_has_transit_path()
int set transit_asns;
{
    transit_asns = TRANSIT_ASNS;
    if (bgp_path ~ transit_asns) then {
        bgp_large_community.add( IXP_LC_FILTERED_TRANSIT_FREE_ASN );
        return true;
    }

    return false;
}


########################################################################################
########################################################################################
#
# Route Server client configuration
#
########################################################################################
########################################################################################


template bgp tb_rsclient {
    local as routeserverasn;
    source address routeserveraddress;
    strict bind yes;

    # give RPKI-RTR a chance to start and populate
    # (RPKI is /really/ quick)
    connect delay time 30;

    interpret communities off;  # enable rfc1997 well-known community pass through

    ipv6 {
        export all;
    };

    rs client;
}




########################################################################################
########################################################################################
#
# Route server clients
#
########################################################################################
########################################################################################


########################################################################################
########################################################################################
###
### AS1213 - HEAnet - VLAN Interface #1

ipv6 table t_0001_as1213;



filter f_import_as1213
prefix set allnet;
ip set allips;
int set allas;
{

    ########################################################################################
    ########################################################################################
    #
    # UI Based Filtering (import rules) - **WHAT THE RS IS LEARNING FROM THE MEMBER**
    #
    ########################################################################################
    ########################################################################################


    # PREPEND_ONCE to all
    bgp_large_community.add( (routeserverasn,101,0) );


    if ( net = 2001:678:24::/48 ) then {
        # PREPEND_THRICE to Imagine
        bgp_large_community.add( (routeserverasn,103,25441) );
    }


    ########################################################################################
    # End UI Based Filtering - import rules
    ########################################################################################


    # Filter small prefixes
    if ( net ~ [ ::/0{49,128} ] ) then {
        bgp_large_community.add( IXP_LC_FILTERED_PREFIX_LEN_TOO_LONG );
        accept;
    }


    if !(avoid_martians()) then {
        bgp_large_community.add( IXP_LC_FILTERED_BOGON );
        accept;
    }

    # Belt and braces: must have at least one ASN in the path
    if( bgp_path.len < 1 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_AS_PATH_TOO_SHORT );
        accept;
    }

    # Peer ASN == route's first ASN?
    if (bgp_path.first != 1213 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_FIRST_AS_NOT_PEER_AS );
        accept;
    }

    # set of all IPs this ASN uses to peer with on this VLAN
    allips = [ 2001:db8:1::10 ];

    # Prevent BGP NEXT_HOP Hijacking
    if !( from = bgp_next_hop ) then {

        # need to differentiate between same ASN next hop or actual next hop hijacking
        if( bgp_next_hop ~ allips ) then {
            bgp_large_community.add( IXP_LC_INFO_SAME_AS_NEXT_HOP );
        } else {
            # looks like hijacking (intentional or not)
            bgp_large_community.add( IXP_LC_FILTERED_NEXT_HOP_NOT_PEER_IP );
            accept;
        }
    }


    # Filter Known Transit Networks
    if filter_has_transit_path() then accept;

    # Belt and braces: no one needs an ASN path with > 64 hops, that's just broken
    if( bgp_path.len > 64 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_AS_PATH_TOO_LONG );
        accept;
    }


        
    allas = [ 112,   1213,  1921,  2128,  2850,  42310
    ];


    # Ensure origin ASN is in the neighbors AS-SET
    if !(bgp_path.last_nonaggregated ~ allas) then {
        bgp_large_community.add( IXP_LC_FILTERED_IRRDB_ORIGIN_AS_FILTERED );
        accept;
    }



    # RPKI test - if it's INVALID or VALID, we are done
    if filter_rpki() then accept;




    allnet = [ 2001:678:20::/48,                   2001:678:24::/48,                   2001:67c:1bc::/48,                  2001:67c:10b8::/48,
               2001:67c:10e0::/48,                 2001:770::/32,                      2001:7f8:18::/48,                   2001:1900:2205::/48,
               2001:1900:2206::/48,                2620:4f:8000::/48,                  2a01:4b0::/32
    ];

    if ! (net ~ allnet) then {
        bgp_large_community.add( IXP_LC_FILTERED_IRRDB_PREFIX_FILTERED );
        bgp_large_community.add( IXP_LC_INFO_IRRDB_FILTERED_STRICT );
        accept;
    } else {
        bgp_large_community.add( IXP_LC_INFO_IRRDB_VALID );
    }



    accept;
}


# The route server export filter exists as the export gateway on the BGP protocol.
#
# Remember that standard IXP community filtering has already happened on the
# master -> bgp protocol pipe.

filter f_export_as1213{



    # we should strip our own communities which we used for the looking glass and filtering
    bgp_large_community.delete( [( routeserverasn, *, * )] );
    bgp_community.delete( [( routeserverasn, * )] );

    ############################################################################################
    ############################################################################################
    #
    # UI Based Filtering (export rules) - **THIRD PARTY ROUTES THE RS IS SENDING TO THE MEMBER**
    #
    ############################################################################################
    ############################################################################################


    # PREPEND_ONCE
    bgp_path.prepend( bgp_path.first );


    if ( bgp_path.first = 25441 ) then {
        if ( net = 2001:4d68::/32 ) then {
            # PREPEND_THRICE
            bgp_path.prepend( bgp_path.first );
            bgp_path.prepend( bgp_path.first );
            bgp_path.prepend( bgp_path.first );
        }
    }


    # AS_IS - a no-op but we accept here as 'first rule matches'
    accept;

    ########################################################################################
    # End UI Based Filtering - export rules
    ########################################################################################

    # default position is to accept:
    accept;

}






    
protocol pipe pp_0001_as1213 {
        description "Pipe for AS1213 - HEAnet - VLAN Interface 1";
        table master6;
        peer table t_0001_as1213;
        import filter f_export_to_master;
        export where ixp_community_filter(1213);
}

protocol bgp pb_0001_as1213 from tb_rsclient {
        description "AS1213 - HEAnet";
        neighbor 2001:db8:1::10 as 1213;
        ipv6 {
            import limit 1000 action restart;
            import filter f_import_as1213;
            table t_0001_as1213;
            export filter f_export_as1213;
        };
        password "N7rX2SdfbRsyBLTm";
}


########################################################################################
########################################################################################
###
### AS25441 - Imagine - VLAN Interface #6

ipv6 table t_0006_as25441;



filter f_import_as25441
prefix set allnet;
ip set allips;
int set allas;
{


    # Filter small prefixes
    if ( net ~ [ ::/0{49,128} ] ) then {
        bgp_large_community.add( IXP_LC_FILTERED_PREFIX_LEN_TOO_LONG );
        accept;
    }


    if !(avoid_martians()) then {
        bgp_large_community.add( IXP_LC_FILTERED_BOGON );
        accept;
    }

    # Belt and braces: must have at least one ASN in the path
    if( bgp_path.len < 1 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_AS_PATH_TOO_SHORT );
        accept;
    }

    # Peer ASN == route's first ASN?
    if (bgp_path.first != 25441 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_FIRST_AS_NOT_PEER_AS );
        accept;
    }

    # set of all IPs this ASN uses to peer with on this VLAN
    allips = [ 2001:db8:1::8 ];

    # Prevent BGP NEXT_HOP Hijacking
    if !( from = bgp_next_hop ) then {

        # need to differentiate between same ASN next hop or actual next hop hijacking
        if( bgp_next_hop ~ allips ) then {
            bgp_large_community.add( IXP_LC_INFO_SAME_AS_NEXT_HOP );
        } else {
            # looks like hijacking (intentional or not)
            bgp_large_community.add( IXP_LC_FILTERED_NEXT_HOP_NOT_PEER_IP );
            accept;
        }
    }


    # Filter Known Transit Networks
    if filter_has_transit_path() then accept;

    # Belt and braces: no one needs an ASN path with > 64 hops, that's just broken
    if( bgp_path.len > 64 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_AS_PATH_TOO_LONG );
        accept;
    }


        
    allas = [ 11521, 25441, 34317, 35272, 39064, 43178, 43610, 47615, 48342, 49573,
              197853, 197904
    ];


    # Ensure origin ASN is in the neighbors AS-SET
    if !(bgp_path.last_nonaggregated ~ allas) then {
        bgp_large_community.add( IXP_LC_FILTERED_IRRDB_ORIGIN_AS_FILTERED );
        accept;
    }



    # RPKI test - if it's INVALID or VALID, we are done
    if filter_rpki() then accept;




    allnet = [ 2001:67c:338::/48,                  2001:4d68::/32{32,48},              2a01:268::/32{32,48},               2a01:8f80::/32{32,48}
    ];

    if ! (net ~ allnet) then {
        bgp_large_community.add( IXP_LC_FILTERED_IRRDB_PREFIX_FILTERED );
        bgp_large_community.add( IXP_LC_INFO_IRRDB_FILTERED_LOOSE );
        accept;
    } else {
        bgp_large_community.add( IXP_LC_INFO_IRRDB_VALID );
    }



    accept;
}


# The route server export filter exists as the export gateway on the BGP protocol.
#
# Remember that standard IXP community filtering has already happened on the
# master -> bgp protocol pipe.

filter f_export_as25441{



    # we should strip our own communities which we used for the looking glass and filtering
    bgp_large_community.delete( [( routeserverasn, *, * )] );
    bgp_community.delete( [( routeserverasn, * )] );

    # default position is to accept:
    accept;

}






    
protocol pipe pp_0006_as25441 {
        description "Pipe for AS25441 - Imagine - VLAN Interface 6";
        table master6;
        peer table t_0006_as25441;
        import filter f_export_to_master;
        export where ixp_community_filter(25441);
}

protocol bgp pb_0006_as25441 from tb_rsclient {
        description "AS25441 - Imagine";
        neighbor 2001:db8:1::8 as 25441;
        ipv6 {
            import limit 1000 action restart;
            import filter f_import_as25441;
            table t_0006_as25441;
            export filter f_export_as25441;
        };
        password "X8Ks9QnbER9cyzU3";
}



