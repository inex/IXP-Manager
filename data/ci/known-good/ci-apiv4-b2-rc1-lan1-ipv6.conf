#
# Bird v2 Route Collector configuration generated by IXP Manager
#
# Do not edit this file, it will be overwritten.
#
# Generated: 2019-03-09 15:47:45
#

# For VLAN: Peering LAN 1 (Tag: 1, Database ID: 1)


# standardise time formats:
timeformat base         iso long;
timeformat log          iso long;
timeformat protocol     iso long;
timeformat route        iso long;


log "/var/log/bird/b2-rc1-lan1-ipv6.log" all;
log syslog all;

define routerasn     = 65500;
define routeraddress = 2001:db8::8;

router id 192.0.2.8;

# ignore interface up/down events
protocol device { }


# This function excludes weird networks
#  rfc1918, class D, class E, too long and too short prefixes
function avoid_martians() -> bool
prefix set martians;
{

    martians = [
        ::/0,                   # Default (can be advertised as a route in BGP to peers if desired)
        ::/96,                  # IPv4-compatible IPv6 address - deprecated by RFC4291
        ::/128,                 # Unspecified address
        ::1/128,                # Local host loopback address
        ::ffff:0.0.0.0/96+,     # IPv4-mapped addresses
        ::224.0.0.0/100+,       # Compatible address (IPv4 format)
        ::127.0.0.0/104+,       # Compatible address (IPv4 format)
        ::0.0.0.0/104+,         # Compatible address (IPv4 format)
        ::255.0.0.0/104+,       # Compatible address (IPv4 format)
        0000::/8+,              # Pool used for unspecified, loopback and embedded IPv4 addresses
        0200::/7+,              # OSI NSAP-mapped prefix set (RFC4548) - deprecated by RFC4048
        3ffe::/16+,             # Former 6bone, now decommissioned
        2001:db8::/32+,         # Reserved by IANA for special purposes and documentation
        2002:e000::/20+,        # Invalid 6to4 packets (IPv4 multicast)
        2002:7f00::/24+,        # Invalid 6to4 packets (IPv4 loopback)
        2002:0000::/24+,        # Invalid 6to4 packets (IPv4 default)
        2002:ff00::/24+,        # Invalid 6to4 packets
        2002:0a00::/24+,        # Invalid 6to4 packets (IPv4 private 10.0.0.0/8 network)
        2002:ac10::/28+,        # Invalid 6to4 packets (IPv4 private 172.16.0.0/12 network)
        2002:c0a8::/32+,        # Invalid 6to4 packets (IPv4 private 192.168.0.0/16 network)
        fc00::/7+,              # Unicast Unique Local Addresses (ULA) - RFC 4193
        fe80::/10+,             # Link-local Unicast
        fec0::/10+,             # Site-local Unicast - deprecated by RFC 3879 (replaced by ULA)
        ff00::/8+               # Multicast
    ];


    # Avoid RFC1918 and similar networks
    if net ~ martians then
        return false;

    return true;
}




##
## Route collector client configuration
##


########################################################################################
########################################################################################
#
# Community filtering definitions for use with looking glasses
#
# Current implementation based on:
#
# https://github.com/euro-ix/rs-workshop-july-2017/wiki/Route-Server-BGP-Community-usage
#
########################################################################################
########################################################################################



# These will all be filtered and not piped to the master table:

define IXP_LC_FILTERED_PREFIX_LEN_TOO_LONG      = ( routerasn, 1101, 1  );
define IXP_LC_FILTERED_PREFIX_LEN_TOO_SHORT     = ( routerasn, 1101, 2  );
define IXP_LC_FILTERED_BOGON                    = ( routerasn, 1101, 3  );
define IXP_LC_FILTERED_BOGON_ASN                = ( routerasn, 1101, 4  );
define IXP_LC_FILTERED_AS_PATH_TOO_LONG         = ( routerasn, 1101, 5  );
define IXP_LC_FILTERED_AS_PATH_TOO_SHORT        = ( routerasn, 1101, 6  );
define IXP_LC_FILTERED_FIRST_AS_NOT_PEER_AS     = ( routerasn, 1101, 7  );
define IXP_LC_FILTERED_NEXT_HOP_NOT_PEER_IP     = ( routerasn, 1101, 8  );
define IXP_LC_FILTERED_IRRDB_PREFIX_FILTERED    = ( routerasn, 1101, 9  );
define IXP_LC_FILTERED_IRRDB_ORIGIN_AS_FILTERED = ( routerasn, 1101, 10 );
define IXP_LC_FILTERED_PREFIX_NOT_IN_ORIGIN_AS  = ( routerasn, 1101, 11 );

define IXP_LC_FILTERED_RPKI_UNKNOWN             = ( routerasn, 1101, 12 );
define IXP_LC_FILTERED_RPKI_INVALID             = ( routerasn, 1101, 13 );
define IXP_LC_FILTERED_TRANSIT_FREE_ASN         = ( routerasn, 1101, 14 );
define IXP_LC_FILTERED_TOO_MANY_COMMUNITIES     = ( routerasn, 1101, 15 );




# Informational prefixes

define IXP_LC_INFO_RPKI_VALID       = ( routerasn, 1000, 1  );
define IXP_LC_INFO_RPKI_UNKNOWN     = ( routerasn, 1000, 2  );
define IXP_LC_INFO_RPKI_NOT_CHECKED = ( routerasn, 1000, 3  );

define IXP_LC_INFO_IRRDB_INVALID       = ( routerasn, 1001, 0  );
define IXP_LC_INFO_IRRDB_VALID         = ( routerasn, 1001, 1  );
define IXP_LC_INFO_IRRDB_NOT_CHECKED   = ( routerasn, 1001, 2  );
define IXP_LC_INFO_IRRDB_MORE_SPECIFIC = ( routerasn, 1001, 3  );

define IXP_LC_INFO_IRRDB_FILTERED_LOOSE  = ( routerasn, 1001, 1000 );
define IXP_LC_INFO_IRRDB_FILTERED_STRICT = ( routerasn, 1001, 1001 );
define IXP_LC_INFO_IRRDB_PREFIX_EMPTY    = ( routerasn, 1001, 1002 );

define IXP_LC_INFO_FROM_IXROUTESERVER = ( routerasn, 1001, 1100 );

define IXP_LC_INFO_SAME_AS_NEXT_HOP = ( routerasn, 1001, 1200 );




########################################################################################
########################################################################################
#
# RPKI protocol configuration
#
########################################################################################
########################################################################################


roa6 table t_roa;

protocol rpki rpki1 {

    roa6 { table t_roa; };

    remote "10.39.5.123" port 3323;

    retry keep 90;
    refresh keep 900;
    expire keep 172800;
}

    
protocol rpki rpki2 {

    roa6 { table t_roa; };

    remote "10.39.5.124" port 3323;

    retry keep 90;
    refresh keep 900;
    expire keep 172800;
}

    



########################################################################################
########################################################################################
#
# Filter known transit networks
#
# Inspired by: http://bgpfilterguide.nlnog.net/guides/no_transit_leaks/
#
########################################################################################
########################################################################################


define TRANSIT_ASNS = [ 174, 701, 1299, 2914, 3257, 3320, 3356, 3491, 4134, 5511, 6453, 6461, 6762, 6830, 7018 ];

function filter_has_transit_path() -> bool
int set transit_asns;
{
    transit_asns = TRANSIT_ASNS;
    if (bgp_path ~ transit_asns) then {
        bgp_large_community.add( IXP_LC_FILTERED_TRANSIT_FREE_ASN );
        return true;
    }

    return false;
}




########################################################################################
########################################################################################
#
# Route collector clients
#
########################################################################################
########################################################################################


########################################################################################
########################################################################################
###
### AS1213 - HEAnet - VLAN Interface #1



function f_import_as1213() -> bool

prefix set allnet;
ip set allips;
int set allas;
{

    
    # From: api/v4/router/collector/bird2/import-pre-extra)
    # This file can be skinned to add custom config to
    # the fn_import function here. For example, INEX uses
    # it to tag routes learnt from our own route servers
    # with an information community and accept them as is.


    # Filter small prefixes
    if ( net ~ [ ::/0{49,128} ] ) then {
        bgp_large_community.add( IXP_LC_FILTERED_PREFIX_LEN_TOO_LONG );
    }


    if !(avoid_martians()) then {
        bgp_large_community.add( IXP_LC_FILTERED_BOGON );
    }

    # Belt and braces: must have at least one ASN in the path
    if( bgp_path.len < 1 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_AS_PATH_TOO_SHORT );
        # we won't continue in this case: zero path asn is broken
        return true;
    }

    # Peer ASN == route's first ASN?
    if (bgp_path.first != 1213 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_FIRST_AS_NOT_PEER_AS );
    }

    # set of all IPs this ASN uses to peer with on this VLAN
    allips = [ 2001:db8:1::10 ];

    # Prevent BGP NEXT_HOP Hijacking
    if !( from = bgp_next_hop ) then {

        # need to differentiate between same ASN next hop or actual next hop hijacking
        if( bgp_next_hop ~ allips ) then {
            bgp_large_community.add( IXP_LC_INFO_SAME_AS_NEXT_HOP );
        } else {
            # looks like hijacking (intentional or not)
            bgp_large_community.add( IXP_LC_FILTERED_NEXT_HOP_NOT_PEER_IP );
        }
    }

    # Filter Known Transit Networks
    filter_has_transit_path();

    # Belt and braces: no one needs an ASN path with > 64 hops, that's just broken
    if( bgp_path.len > 64 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_AS_PATH_TOO_LONG );
    }



    allas = [ 112,   1213,  1921,  2128,  2850,  42310
    ];

        
    # Ensure origin ASN is in the neighbors AS-SET
    if !(bgp_path.last_nonaggregated ~ allas) then {
        bgp_large_community.add( IXP_LC_FILTERED_IRRDB_ORIGIN_AS_FILTERED );
    }





    # RPKI check
    if( roa_check( t_roa, net, bgp_path.last_nonaggregated ) = ROA_INVALID ) then {
        bgp_large_community.add( IXP_LC_FILTERED_RPKI_INVALID );
    } else if( roa_check( t_roa, net, bgp_path.last_nonaggregated ) = ROA_VALID ) then {
        bgp_large_community.add( IXP_LC_INFO_RPKI_VALID );
    } else {
        # RPKI unknown, keep checking and mark as unknown for info
        bgp_large_community.add( IXP_LC_INFO_RPKI_UNKNOWN );
    }






    allnet = [ 2001:678:20::/48,                   2001:678:24::/48,                   2001:67c:1bc::/48,                  2001:67c:10b8::/48,
               2001:67c:10e0::/48,                 2001:770::/32,                      2001:7f8:18::/48,                   2001:1900:2205::/48,
               2001:1900:2206::/48,                2620:4f:8000::/48,                  2a01:4b0::/32
    ];

    if ! (net ~ allnet) then {
        if bgp_large_community ~ [IXP_LC_INFO_RPKI_VALID] then {
            bgp_large_community.add( IXP_LC_INFO_IRRDB_INVALID );
        } else {
            bgp_large_community.add( IXP_LC_FILTERED_IRRDB_PREFIX_FILTERED );
        }

        bgp_large_community.add( IXP_LC_INFO_IRRDB_FILTERED_STRICT );
    } else {
        bgp_large_community.add( IXP_LC_INFO_IRRDB_VALID );
    }

        
    


    return true;
}




protocol bgp pb_as1213_vli1_ipv6 {
    description "AS1213 - HEAnet";
    local as routerasn;
    source address routeraddress;
    strict bind yes;
    neighbor 2001:db8:1::10 as 1213;

    ipv6 {
        # As a route collector, we want to import everything and export nothing.
        # The import filter listed here just accepts everything but adds tags.
        import where f_import_as1213();
        export none;
    };

    password "N7rX2SdfbRsyBLTm";
}


########################################################################################
########################################################################################
###
### AS25441 - Imagine - VLAN Interface #6



function f_import_as25441() -> bool

prefix set allnet;
ip set allips;
int set allas;
{

    
    # From: api/v4/router/collector/bird2/import-pre-extra)
    # This file can be skinned to add custom config to
    # the fn_import function here. For example, INEX uses
    # it to tag routes learnt from our own route servers
    # with an information community and accept them as is.


    # Filter small prefixes
    if ( net ~ [ ::/0{49,128} ] ) then {
        bgp_large_community.add( IXP_LC_FILTERED_PREFIX_LEN_TOO_LONG );
    }


    if !(avoid_martians()) then {
        bgp_large_community.add( IXP_LC_FILTERED_BOGON );
    }

    # Belt and braces: must have at least one ASN in the path
    if( bgp_path.len < 1 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_AS_PATH_TOO_SHORT );
        # we won't continue in this case: zero path asn is broken
        return true;
    }

    # Peer ASN == route's first ASN?
    if (bgp_path.first != 25441 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_FIRST_AS_NOT_PEER_AS );
    }

    # set of all IPs this ASN uses to peer with on this VLAN
    allips = [ 2001:db8:1::8 ];

    # Prevent BGP NEXT_HOP Hijacking
    if !( from = bgp_next_hop ) then {

        # need to differentiate between same ASN next hop or actual next hop hijacking
        if( bgp_next_hop ~ allips ) then {
            bgp_large_community.add( IXP_LC_INFO_SAME_AS_NEXT_HOP );
        } else {
            # looks like hijacking (intentional or not)
            bgp_large_community.add( IXP_LC_FILTERED_NEXT_HOP_NOT_PEER_IP );
        }
    }

    # Filter Known Transit Networks
    filter_has_transit_path();

    # Belt and braces: no one needs an ASN path with > 64 hops, that's just broken
    if( bgp_path.len > 64 ) then {
        bgp_large_community.add( IXP_LC_FILTERED_AS_PATH_TOO_LONG );
    }



    allas = [ 11521, 25441, 34317, 35272, 39064, 43178, 43610, 47615, 48342, 49573,
              197853, 197904
    ];

        
    # Ensure origin ASN is in the neighbors AS-SET
    if !(bgp_path.last_nonaggregated ~ allas) then {
        bgp_large_community.add( IXP_LC_FILTERED_IRRDB_ORIGIN_AS_FILTERED );
    }





    # RPKI check
    if( roa_check( t_roa, net, bgp_path.last_nonaggregated ) = ROA_INVALID ) then {
        bgp_large_community.add( IXP_LC_FILTERED_RPKI_INVALID );
    } else if( roa_check( t_roa, net, bgp_path.last_nonaggregated ) = ROA_VALID ) then {
        bgp_large_community.add( IXP_LC_INFO_RPKI_VALID );
    } else {
        # RPKI unknown, keep checking and mark as unknown for info
        bgp_large_community.add( IXP_LC_INFO_RPKI_UNKNOWN );
    }






    allnet = [ 2001:67c:338::/48,                  2001:4d68::/32{32,48},              2a01:268::/32{32,48},               2a01:8f80::/32{32,48}
    ];

    if ! (net ~ allnet) then {
        if bgp_large_community ~ [IXP_LC_INFO_RPKI_VALID] then {
            bgp_large_community.add( IXP_LC_INFO_IRRDB_INVALID );
        } else {
            bgp_large_community.add( IXP_LC_FILTERED_IRRDB_PREFIX_FILTERED );
        }

        bgp_large_community.add( IXP_LC_INFO_IRRDB_FILTERED_LOOSE );
    } else {
        bgp_large_community.add( IXP_LC_INFO_IRRDB_VALID );
    }

        
    


    return true;
}




protocol bgp pb_as25441_vli6_ipv6 {
    description "AS25441 - Imagine";
    local as routerasn;
    source address routeraddress;
    strict bind yes;
    neighbor 2001:db8:1::8 as 25441;

    ipv6 {
        # As a route collector, we want to import everything and export nothing.
        # The import filter listed here just accepts everything but adds tags.
        import where f_import_as25441();
        export none;
    };

    password "X8Ks9QnbER9cyzU3";
}


